{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/runner/work/davidcsally.github.io/davidcsally.github.io/node_modules/next/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/runner/work/davidcsally.github.io/davidcsally.github.io/node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/home/runner/work/davidcsally.github.io/davidcsally.github.io/node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nexports.__esModule = true;\nexports.getDomainLocale = getDomainLocale;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.default = void 0;\n\nvar _normalizeTrailingSlash = require(\"../../../client/normalize-trailing-slash\");\n\nvar _routeLoader = require(\"../../../client/route-loader\");\n\nvar _denormalizePagePath = require(\"../../server/denormalize-page-path\");\n\nvar _normalizeLocalePath = require(\"../i18n/normalize-locale-path\");\n\nvar _mitt = _interopRequireDefault(require(\"../mitt\"));\n\nvar _utils = require(\"../utils\");\n\nvar _isDynamic = require(\"./utils/is-dynamic\");\n\nvar _parseRelativeUrl = require(\"./utils/parse-relative-url\");\n\nvar _querystring = require(\"./utils/querystring\");\n\nvar _resolveRewrites = _interopRequireDefault(require(\"./utils/resolve-rewrites\"));\n\nvar _routeMatcher = require(\"./utils/route-matcher\");\n\nvar _routeRegex = require(\"./utils/route-regex\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* global __NEXT_DATA__ */\n// tslint:disable:no-console\n\n\nlet detectDomainLocale;\n\nif (process.env.__NEXT_I18N_SUPPORT) {\n  detectDomainLocale = require('../i18n/detect-domain-locale').detectDomainLocale;\n}\n\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\n\nfunction buildCancellationError() {\n  return Object.assign(new Error('Route Cancelled'), {\n    cancelled: true\n  });\n}\n\nfunction addPathPrefix(path, prefix) {\n  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : \"\".concat(prefix).concat(pathNoQueryHash(path) === '/' ? path.substring(1) : path) : path;\n}\n\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n  if (process.env.__NEXT_I18N_SUPPORT) {\n    locale = locale || (0, _normalizeLocalePath.normalizeLocalePath)(path, locales).detectedLocale;\n    const detectedDomain = detectDomainLocale(domainLocales, undefined, locale);\n\n    if (detectedDomain) {\n      return \"http\".concat(detectedDomain.http ? '' : 's', \"://\").concat(detectedDomain.domain).concat(basePath || '').concat(locale === detectedDomain.defaultLocale ? '' : \"/\".concat(locale)).concat(path);\n    }\n\n    return false;\n  }\n\n  return false;\n}\n\nfunction addLocale(path, locale, defaultLocale) {\n  if (process.env.__NEXT_I18N_SUPPORT) {\n    return locale && locale !== defaultLocale && !path.startsWith('/' + locale + '/') && path !== '/' + locale ? addPathPrefix(path, '/' + locale) : path;\n  }\n\n  return path;\n}\n\nfunction delLocale(path, locale) {\n  if (process.env.__NEXT_I18N_SUPPORT) {\n    return locale && (path.startsWith('/' + locale + '/') || path === '/' + locale) ? path.substr(locale.length + 1) || '/' : path;\n  }\n\n  return path;\n}\n\nfunction pathNoQueryHash(path) {\n  const queryIndex = path.indexOf('?');\n  const hashIndex = path.indexOf('#');\n\n  if (queryIndex > -1 || hashIndex > -1) {\n    path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);\n  }\n\n  return path;\n}\n\nfunction hasBasePath(path) {\n  path = pathNoQueryHash(path);\n  return path === basePath || path.startsWith(basePath + '/');\n}\n\nfunction addBasePath(path) {\n  // we only add the basepath on relative urls\n  return addPathPrefix(path, basePath);\n}\n\nfunction delBasePath(path) {\n  path = path.slice(basePath.length);\n  if (!path.startsWith('/')) path = \"/\".concat(path);\n  return path;\n}\n/**\n* Detects whether a given url is routable by the Next.js router (browser only).\n*/\n\n\nfunction isLocalURL(url) {\n  // prevent a hydration mismatch on href for url with anchor refs\n  if (url.startsWith('/') || url.startsWith('#')) return true;\n\n  try {\n    // absolute urls can be local if they are on the same origin\n    const locationOrigin = (0, _utils.getLocationOrigin)();\n    const resolved = new URL(url, locationOrigin);\n    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction interpolateAs(route, asPathname, query) {\n  let interpolatedRoute = '';\n  const dynamicRegex = (0, _routeRegex.getRouteRegex)(route);\n  const dynamicGroups = dynamicRegex.groups;\n  const dynamicMatches = // Try to match the dynamic route against the asPath\n  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href\n  // TODO: should this take priority; also need to change in the router.\n  query;\n  interpolatedRoute = route;\n  const params = Object.keys(dynamicGroups);\n\n  if (!params.every(param => {\n    let value = dynamicMatches[param] || '';\n    const _dynamicGroups$param = dynamicGroups[param],\n          repeat = _dynamicGroups$param.repeat,\n          optional = _dynamicGroups$param.optional; // support single-level catch-all\n    // TODO: more robust handling for user-error (passing `/`)\n\n    let replaced = \"[\".concat(repeat ? '...' : '').concat(param, \"]\");\n\n    if (optional) {\n      replaced = \"\".concat(!value ? '/' : '', \"[\").concat(replaced, \"]\");\n    }\n\n    if (repeat && !Array.isArray(value)) value = [value];\n    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present\n    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just\n    // path delimiter escaped since they are being inserted\n    // into the URL and we expect URL encoded segments\n    // when parsing dynamic route params\n    segment => encodeURIComponent(segment)).join('/') : encodeURIComponent(value)) || '/');\n  })) {\n    interpolatedRoute = ''; // did not satisfy all requirements\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n  }\n\n  return {\n    params,\n    result: interpolatedRoute\n  };\n}\n\nfunction omitParmsFromQuery(query, params) {\n  const filteredQuery = {};\n  Object.keys(query).forEach(key => {\n    if (!params.includes(key)) {\n      filteredQuery[key] = query[key];\n    }\n  });\n  return filteredQuery;\n}\n/**\n* Resolves a given hyperlink with a certain router state (basePath not included).\n* Preserves absolute urls.\n*/\n\n\nfunction resolveHref(currentPath, href, resolveAs) {\n  // we use a dummy base url for relative urls\n  const base = new URL(currentPath, 'http://n');\n  const urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href); // Return because it cannot be routed by the Next.js router\n\n  if (!isLocalURL(urlAsString)) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n\n  try {\n    const finalUrl = new URL(urlAsString, base);\n    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);\n    let interpolatedAs = '';\n\n    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n      const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n\n      const _interpolateAs = interpolateAs(finalUrl.pathname, finalUrl.pathname, query),\n            result = _interpolateAs.result,\n            params = _interpolateAs.params;\n\n      if (result) {\n        interpolatedAs = (0, _utils.formatWithValidation)({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: omitParmsFromQuery(query, params)\n        });\n      }\n    } // if the origin didn't change, it means we received a relative href\n\n\n    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;\n  } catch (_) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n}\n\nfunction stripOrigin(url) {\n  const origin = (0, _utils.getLocationOrigin)();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\n\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  let _resolveHref = resolveHref(router.pathname, url, true),\n      _resolveHref2 = _slicedToArray(_resolveHref, 2),\n      resolvedHref = _resolveHref2[0],\n      resolvedAs = _resolveHref2[1];\n\n  const origin = (0, _utils.getLocationOrigin)();\n  const hrefHadOrigin = resolvedHref.startsWith(origin);\n  const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  const preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);\n  const preparedAs = as ? stripOrigin(resolveHref(router.pathname, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asHadOrigin ? preparedAs : addBasePath(preparedAs)\n  };\n}\n\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && true && 'scrollRestoration' in window.history && !!function () {\n  try {\n    let v = '__next'; // eslint-disable-next-line no-sequences\n\n    return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n  } catch (n) {}\n}();\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\n\nfunction fetchRetry(url, attempts) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: 'same-origin'\n  }).then(res => {\n    if (!res.ok) {\n      if (attempts > 1 && res.status >= 500) {\n        return fetchRetry(url, attempts - 1);\n      }\n\n      if (res.status === 404) {\n        return res.json().then(data => {\n          if (data.notFound) {\n            return {\n              notFound: SSG_DATA_NOT_FOUND\n            };\n          }\n\n          throw new Error(\"Failed to load static props\");\n        });\n      }\n\n      throw new Error(\"Failed to load static props\");\n    }\n\n    return res.json();\n  });\n}\n\nfunction fetchNextData(dataHref, isServerRender) {\n  return fetchRetry(dataHref, isServerRender ? 3 : 1).catch(err => {\n    // We should only trigger a server-side transition if this was caused\n    // on a client-side transition. Otherwise, we'd get into an infinite\n    // loop.\n    if (!isServerRender) {\n      (0, _routeLoader.markAssetError)(err);\n    }\n\n    throw err;\n  });\n}\n\nclass Router {\n  /**\n  * Map of all components loaded in `Router`\n  */\n  // Static Data Cache\n  constructor(_pathname, _query, _as, {\n    initialProps,\n    pageLoader,\n    App,\n    wrapApp,\n    Component,\n    err,\n    subscription,\n    isFallback,\n    locale,\n    locales,\n    defaultLocale,\n    domainLocales\n  }) {\n    this.route = void 0;\n    this.pathname = void 0;\n    this.query = void 0;\n    this.asPath = void 0;\n    this.basePath = void 0;\n    this.components = void 0;\n    this.sdc = {};\n    this.sub = void 0;\n    this.clc = void 0;\n    this.pageLoader = void 0;\n    this._bps = void 0;\n    this.events = void 0;\n    this._wrapApp = void 0;\n    this.isSsr = void 0;\n    this.isFallback = void 0;\n    this._inFlightRoute = void 0;\n    this._shallow = void 0;\n    this.locale = void 0;\n    this.locales = void 0;\n    this.defaultLocale = void 0;\n    this.domainLocales = void 0;\n    this.isReady = void 0;\n    this._idx = 0;\n\n    this.onPopState = e => {\n      const state = e.state;\n\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        const pathname = this.pathname,\n              query = this.query;\n        this.changeState('replaceState', (0, _utils.formatWithValidation)({\n          pathname: addBasePath(pathname),\n          query\n        }), (0, _utils.getURL)());\n        return;\n      }\n\n      if (!state.__N) {\n        return;\n      }\n\n      let forcedScroll;\n      const url = state.url,\n            as = state.as,\n            options = state.options,\n            idx = state.idx;\n\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          if (this._idx !== idx) {\n            // Snapshot current scroll position:\n            try {\n              sessionStorage.setItem('__next_scroll_' + this._idx, JSON.stringify({\n                x: self.pageXOffset,\n                y: self.pageYOffset\n              }));\n            } catch (_unused) {} // Restore old scroll position:\n\n\n            try {\n              const v = sessionStorage.getItem('__next_scroll_' + idx);\n              forcedScroll = JSON.parse(v);\n            } catch (_unused2) {\n              forcedScroll = {\n                x: 0,\n                y: 0\n              };\n            }\n          }\n        }\n      }\n\n      this._idx = idx;\n\n      const _ref = (0, _parseRelativeUrl.parseRelativeUrl)(url),\n            pathname = _ref.pathname; // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n\n\n      if (this.isSsr && as === this.asPath && pathname === this.pathname) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n\n\n      if (this._bps && !this._bps(state)) {\n        return;\n      }\n\n      this.change('replaceState', url, as, Object.assign({}, options, {\n        shallow: options.shallow && this._shallow,\n        locale: options.locale || this.defaultLocale\n      }), forcedScroll);\n    }; // represents the current component key\n\n\n    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)\n\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n\n    if (_pathname !== '/_error') {\n      this.components[this.route] = {\n        Component,\n        initial: true,\n        props: initialProps,\n        err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n\n    this.components['/_app'] = {\n      Component: App,\n      styleSheets: [\n        /* /_app does not need its stylesheets managed */\n      ]\n    }; // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n\n    this.events = Router.events;\n    this.pageLoader = pageLoader;\n    this.pathname = _pathname;\n    this.query = _query; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n\n    const autoExportDynamic = (0, _isDynamic.isDynamicRoute)(_pathname) && self.__NEXT_DATA__.autoExport;\n\n    this.asPath = autoExportDynamic ? _pathname : _as;\n    this.basePath = basePath;\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n\n    this.isSsr = true;\n    this.isFallback = isFallback;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || !autoExportDynamic && !self.location.search);\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      this.locale = locale;\n      this.locales = locales;\n      this.defaultLocale = defaultLocale;\n      this.domainLocales = domainLocales;\n    }\n\n    if (true) {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (_as.substr(0, 2) !== '//') {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        this.changeState('replaceState', (0, _utils.formatWithValidation)({\n          pathname: addBasePath(_pathname),\n          query: _query\n        }), (0, _utils.getURL)(), {\n          locale\n        });\n      }\n\n      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          window.history.scrollRestoration = 'manual';\n        }\n      }\n    }\n  }\n\n  reload() {\n    window.location.reload();\n  }\n  /**\n  * Go back in history\n  */\n\n\n  back() {\n    window.history.back();\n  }\n  /**\n  * Performs a `pushState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n\n\n  push(url, as, options = {}) {\n    if (process.env.__NEXT_SCROLL_RESTORATION) {\n      // TODO: remove in the future when we update history before route change\n      // is complete, as the popstate event should handle this capture.\n      if (manualScrollRestoration) {\n        try {\n          // Snapshot scroll position right before navigating to a new page:\n          sessionStorage.setItem('__next_scroll_' + this._idx, JSON.stringify({\n            x: self.pageXOffset,\n            y: self.pageYOffset\n          }));\n        } catch (_unused3) {}\n      }\n    }\n\n    ;\n\n    var _prepareUrlAs = prepareUrlAs(this, url, as);\n\n    url = _prepareUrlAs.url;\n    as = _prepareUrlAs.as;\n    return this.change('pushState', url, as, options);\n  }\n  /**\n  * Performs a `replaceState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n\n\n  replace(url, as, options = {}) {\n    ;\n\n    var _prepareUrlAs2 = prepareUrlAs(this, url, as);\n\n    url = _prepareUrlAs2.url;\n    as = _prepareUrlAs2.as;\n    return this.change('replaceState', url, as, options);\n  }\n\n  change(method, url, as, options, forcedScroll) {\n    var _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var _options$scroll, localeChange, parsedAs, localePathResult, didNavigate, _this$locales, detectedDomain, asNoBasePath, _options$shallow, shallow, routeProps, cleanedAs, parsed, _parsed, pathname, query, pages, rewrites, _yield, route, resolvedAs, rewritesResult, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, routeInfo, _routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, notFoundRoute, appComp, isValidShallowRoute;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (isLocalURL(url)) {\n              _context.next = 3;\n              break;\n            }\n\n            window.location.href = url;\n            return _context.abrupt(\"return\", false);\n\n          case 3:\n            // for static pages with query params in the URL we delay\n            // marking the router ready until after the query is updated\n            if (options._h) {\n              _this.isReady = true;\n            } // Default to scroll reset behavior unless explicitly specified to be\n            // `false`! This makes the behavior between using `Router#push` and a\n            // `<Link />` consistent.\n\n\n            options.scroll = !!((_options$scroll = options.scroll) != null ? _options$scroll : true);\n            localeChange = options.locale !== _this.locale;\n\n            if (!process.env.__NEXT_I18N_SUPPORT) {\n              _context.next = 18;\n              break;\n            }\n\n            _this.locale = options.locale === false ? _this.defaultLocale : options.locale || _this.locale;\n\n            if (typeof options.locale === 'undefined') {\n              options.locale = _this.locale;\n            }\n\n            parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(hasBasePath(as) ? delBasePath(as) : as);\n            localePathResult = (0, _normalizeLocalePath.normalizeLocalePath)(parsedAs.pathname, _this.locales);\n\n            if (localePathResult.detectedLocale) {\n              _this.locale = localePathResult.detectedLocale;\n              parsedAs.pathname = addBasePath(parsedAs.pathname);\n              as = (0, _utils.formatWithValidation)(parsedAs);\n              url = addBasePath((0, _normalizeLocalePath.normalizeLocalePath)(hasBasePath(url) ? delBasePath(url) : url, _this.locales).pathname);\n            }\n\n            didNavigate = false; // we need to wrap this in the env check again since regenerator runtime\n            // moves this on its own due to the return\n\n            if (process.env.__NEXT_I18N_SUPPORT) {\n              // if the locale isn't configured hard navigate to show 404 page\n              if (!((_this$locales = _this.locales) != null && _this$locales.includes(_this.locale))) {\n                parsedAs.pathname = addLocale(parsedAs.pathname, _this.locale);\n                window.location.href = (0, _utils.formatWithValidation)(parsedAs); // this was previously a return but was removed in favor\n                // of better dead code elimination with regenerator runtime\n\n                didNavigate = true;\n              }\n            }\n\n            detectedDomain = detectDomainLocale(_this.domainLocales, undefined, _this.locale); // we need to wrap this in the env check again since regenerator runtime\n            // moves this on its own due to the return\n\n            if (process.env.__NEXT_I18N_SUPPORT) {\n              // if we are navigating to a domain locale ensure we redirect to the\n              // correct domain\n              if (!didNavigate && detectedDomain && self.location.hostname !== detectedDomain.domain) {\n                asNoBasePath = delBasePath(as);\n                window.location.href = \"http\".concat(detectedDomain.http ? '' : 's', \"://\").concat(detectedDomain.domain).concat(addBasePath(\"\".concat(_this.locale === detectedDomain.defaultLocale ? '' : \"/\".concat(_this.locale)).concat(asNoBasePath === '/' ? '' : asNoBasePath) || '/')); // this was previously a return but was removed in favor\n                // of better dead code elimination with regenerator runtime\n\n                didNavigate = true;\n              }\n            }\n\n            if (!didNavigate) {\n              _context.next = 18;\n              break;\n            }\n\n            return _context.abrupt(\"return\", new Promise(() => {}));\n\n          case 18:\n            if (!options._h) {\n              _this.isSsr = false;\n            } // marking route changes as a navigation start entry\n\n\n            if (_utils.ST) {\n              performance.mark('routeChange');\n            }\n\n            _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow;\n            routeProps = {\n              shallow\n            };\n\n            if (_this._inFlightRoute) {\n              _this.abortComponentLoad(_this._inFlightRoute, routeProps);\n            }\n\n            as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, _this.defaultLocale));\n            cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, _this.locale);\n            _this._inFlightRoute = as; // If the url change is only related to a hash change\n            // We should not proceed. We should only change the state.\n            // WARNING: `_h` is an internal option for handing Next.js client-side\n            // hydration. Your app should _never_ use this property. It may change at\n            // any time without notice.\n\n            if (!(!options._h && _this.onlyAHashChange(cleanedAs))) {\n              _context.next = 34;\n              break;\n            }\n\n            _this.asPath = cleanedAs;\n            Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?\n\n            _this.changeState(method, url, as, options);\n\n            _this.scrollToHash(cleanedAs);\n\n            _this.notify(_this.components[_this.route], null);\n\n            Router.events.emit('hashChangeComplete', as, routeProps);\n            return _context.abrupt(\"return\", true);\n\n          case 34:\n            parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);\n            _parsed = parsed, pathname = _parsed.pathname, query = _parsed.query; // The build manifest needs to be loaded before auto-static dynamic pages\n            // get their query parameters to allow ensuring they can be parsed properly\n            // when rewritten to\n\n            _context.prev = 36;\n            _context.next = 39;\n            return _this.pageLoader.getPageList();\n\n          case 39:\n            pages = _context.sent;\n            _context.next = 42;\n            return (0, _routeLoader.getClientBuildManifest)();\n\n          case 42:\n            _yield = _context.sent;\n            rewrites = _yield.__rewrites;\n            _context.next = 50;\n            break;\n\n          case 46:\n            _context.prev = 46;\n            _context.t0 = _context[\"catch\"](36);\n            // If we fail to resolve the page list or client-build manifest, we must\n            // do a server-side transition:\n            window.location.href = as;\n            return _context.abrupt(\"return\", false);\n\n          case 50:\n            parsed = _this._resolveHref(parsed, pages);\n\n            if (parsed.pathname !== pathname) {\n              pathname = parsed.pathname;\n              url = (0, _utils.formatWithValidation)(parsed);\n            } // url and as should always be prefixed with basePath by this\n            // point by either next/link or router.push/replace so strip the\n            // basePath from the pathname to match the pages dir 1-to-1\n\n\n            pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname; // If asked to change the current URL we should reload the current page\n            // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n            // We also need to set the method = replaceState always\n            // as this should not go into the history (That's how browsers work)\n            // We should compare the new asPath to the current asPath, not the url\n\n            if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n              method = 'replaceState';\n            }\n\n            route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname); // we need to resolve the as value using rewrites for dynamic SSG\n            // pages to allow building the data URL correctly\n\n            resolvedAs = as;\n\n            if (process.env.__NEXT_HAS_REWRITES && as.startsWith('/')) {\n              rewritesResult = (0, _resolveRewrites.default)(addBasePath(addLocale(delBasePath(as), _this.locale)), pages, rewrites, query, p => _this._resolveHref({\n                pathname: p\n              }, pages).pathname, _this.locales);\n              resolvedAs = rewritesResult.asPath;\n\n              if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                // if this directly matches a page we need to update the href to\n                // allow the correct page chunk to be loaded\n                route = rewritesResult.resolvedHref;\n                pathname = rewritesResult.resolvedHref;\n                parsed.pathname = pathname;\n                url = (0, _utils.formatWithValidation)(parsed);\n              }\n            }\n\n            if (isLocalURL(as)) {\n              _context.next = 62;\n              break;\n            }\n\n            if (!false) {\n              _context.next = 60;\n              break;\n            }\n\n            throw new Error(\"Invalid href: \\\"\".concat(url, \"\\\" and as: \\\"\").concat(as, \"\\\", received relative href and external as\") + \"\\nSee more info: https://err.sh/next.js/invalid-relative-url-external-as\");\n\n          case 60:\n            window.location.href = as;\n            return _context.abrupt(\"return\", false);\n\n          case 62:\n            resolvedAs = delLocale(delBasePath(resolvedAs), _this.locale);\n\n            if (!(0, _isDynamic.isDynamicRoute)(route)) {\n              _context.next = 78;\n              break;\n            }\n\n            parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);\n            asPathname = parsedAs.pathname;\n            routeRegex = (0, _routeRegex.getRouteRegex)(route);\n            routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);\n            shouldInterpolate = route === asPathname;\n            interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n\n            if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n              _context.next = 77;\n              break;\n            }\n\n            missingParams = Object.keys(routeRegex.groups).filter(param => !query[param]);\n\n            if (!(missingParams.length > 0)) {\n              _context.next = 75;\n              break;\n            }\n\n            if (false) {\n              console.warn(\"\".concat(shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\", \" failed to manually provide \") + \"the params: \".concat(missingParams.join(', '), \" in the `href`'s `query`\"));\n            }\n\n            throw new Error((shouldInterpolate ? \"The provided `href` (\".concat(url, \") value is missing query values (\").concat(missingParams.join(', '), \") to be interpolated properly. \") : \"The provided `as` value (\".concat(asPathname, \") is incompatible with the `href` value (\").concat(route, \"). \")) + \"Read more: https://err.sh/vercel/next.js/\".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));\n\n          case 75:\n            _context.next = 78;\n            break;\n\n          case 77:\n            if (shouldInterpolate) {\n              as = (0, _utils.formatWithValidation)(Object.assign({}, parsedAs, {\n                pathname: interpolatedAs.result,\n                query: omitParmsFromQuery(query, interpolatedAs.params)\n              }));\n            } else {\n              // Merge params into `query`, overwriting any specified in search\n              Object.assign(query, routeMatch);\n            }\n\n          case 78:\n            Router.events.emit('routeChangeStart', as, routeProps);\n            _context.prev = 79;\n            _context.next = 82;\n            return _this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps);\n\n          case 82:\n            routeInfo = _context.sent;\n            _routeInfo = routeInfo, error = _routeInfo.error, props = _routeInfo.props, __N_SSG = _routeInfo.__N_SSG, __N_SSP = _routeInfo.__N_SSP; // handle redirect on client-transition\n\n            if (!((__N_SSG || __N_SSP) && props)) {\n              _context.next = 108;\n              break;\n            }\n\n            if (!(props.pageProps && props.pageProps.__N_REDIRECT)) {\n              _context.next = 95;\n              break;\n            }\n\n            destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n            // client-navigation if it is falling back to hard navigation if\n            // it's not\n\n            if (!destination.startsWith('/')) {\n              _context.next = 93;\n              break;\n            }\n\n            parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);\n\n            _this._resolveHref(parsedHref, pages, false);\n\n            if (!pages.includes(parsedHref.pathname)) {\n              _context.next = 93;\n              break;\n            }\n\n            _prepareUrlAs3 = prepareUrlAs(_this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;\n            return _context.abrupt(\"return\", _this.change(method, newUrl, newAs, options));\n\n          case 93:\n            window.location.href = destination;\n            return _context.abrupt(\"return\", new Promise(() => {}));\n\n          case 95:\n            if (!(props.notFound === SSG_DATA_NOT_FOUND)) {\n              _context.next = 108;\n              break;\n            }\n\n            _context.prev = 96;\n            _context.next = 99;\n            return _this.fetchComponent('/404');\n\n          case 99:\n            notFoundRoute = '/404';\n            _context.next = 105;\n            break;\n\n          case 102:\n            _context.prev = 102;\n            _context.t1 = _context[\"catch\"](96);\n            notFoundRoute = '/_error';\n\n          case 105:\n            _context.next = 107;\n            return _this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {\n              shallow: false\n            });\n\n          case 107:\n            routeInfo = _context.sent;\n\n          case 108:\n            Router.events.emit('beforeHistoryChange', as, routeProps);\n\n            _this.changeState(method, url, as, options);\n\n            if (false) {\n              appComp = _this.components['/_app'].Component;\n              window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;\n            } // shallow routing is only allowed for same page URL changes.\n\n\n            isValidShallowRoute = options.shallow && _this.route === route;\n            _context.next = 114;\n            return _this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll || (isValidShallowRoute || !options.scroll ? null : {\n              x: 0,\n              y: 0\n            })).catch(e => {\n              if (e.cancelled) error = error || e;else throw e;\n            });\n\n          case 114:\n            if (!error) {\n              _context.next = 117;\n              break;\n            }\n\n            Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n            throw error;\n\n          case 117:\n            if (process.env.__NEXT_I18N_SUPPORT) {\n              if (_this.locale) {\n                document.documentElement.lang = _this.locale;\n              }\n            }\n\n            Router.events.emit('routeChangeComplete', as, routeProps);\n            return _context.abrupt(\"return\", true);\n\n          case 122:\n            _context.prev = 122;\n            _context.t2 = _context[\"catch\"](79);\n\n            if (!_context.t2.cancelled) {\n              _context.next = 126;\n              break;\n            }\n\n            return _context.abrupt(\"return\", false);\n\n          case 126:\n            throw _context.t2;\n\n          case 127:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[36, 46], [79, 122], [96, 102]]);\n    }))();\n  }\n\n  changeState(method, url, as, options = {}) {\n    if (false) {\n      if (typeof window.history === 'undefined') {\n        console.error(\"Warning: window.history is not available.\");\n        return;\n      }\n\n      if (typeof window.history[method] === 'undefined') {\n        console.error(\"Warning: window.history.\".concat(method, \" is not available\"));\n        return;\n      }\n    }\n\n    if (method !== 'pushState' || (0, _utils.getURL)() !== as) {\n      this._shallow = options.shallow;\n      window.history[method]({\n        url,\n        as,\n        options,\n        __N: true,\n        idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1\n      }, // Most browsers currently ignores this parameter, although they may use it in the future.\n      // Passing the empty string here should be safe against future changes to the method.\n      // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n      '', as);\n    }\n  }\n\n  handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n    var _this2 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var Component, styleSheets, props, _yield$_this2$fetchCo, routeInfo;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!err.cancelled) {\n              _context2.next = 2;\n              break;\n            }\n\n            throw err;\n\n          case 2:\n            if (!((0, _routeLoader.isAssetError)(err) || loadErrorFail)) {\n              _context2.next = 6;\n              break;\n            }\n\n            Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons\n            //  1. Page doesn't exists\n            //  2. Page does exist in a different zone\n            //  3. Internal error while loading the page\n            // So, doing a hard reload is the proper way to deal with this.\n\n            window.location.href = as; // Changing the URL doesn't block executing the current code path.\n            // So let's throw a cancellation error stop the routing logic.\n\n            throw buildCancellationError();\n\n          case 6:\n            _context2.prev = 6;\n\n            if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {\n              _context2.next = 14;\n              break;\n            }\n\n            ;\n            _context2.next = 11;\n            return _this2.fetchComponent('/_error');\n\n          case 11:\n            _yield$_this2$fetchCo = _context2.sent;\n            Component = _yield$_this2$fetchCo.page;\n            styleSheets = _yield$_this2$fetchCo.styleSheets;\n\n          case 14:\n            routeInfo = {\n              props,\n              Component,\n              styleSheets,\n              err,\n              error: err\n            };\n\n            if (routeInfo.props) {\n              _context2.next = 26;\n              break;\n            }\n\n            _context2.prev = 16;\n            _context2.next = 19;\n            return _this2.getInitialProps(Component, {\n              err,\n              pathname,\n              query\n            });\n\n          case 19:\n            routeInfo.props = _context2.sent;\n            _context2.next = 26;\n            break;\n\n          case 22:\n            _context2.prev = 22;\n            _context2.t0 = _context2[\"catch\"](16);\n            console.error('Error in error page `getInitialProps`: ', _context2.t0);\n            routeInfo.props = {};\n\n          case 26:\n            return _context2.abrupt(\"return\", routeInfo);\n\n          case 29:\n            _context2.prev = 29;\n            _context2.t1 = _context2[\"catch\"](6);\n            return _context2.abrupt(\"return\", _this2.handleRouteInfoError(_context2.t1, pathname, query, as, routeProps, true));\n\n          case 32:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[6, 29], [16, 22]]);\n    }))();\n  }\n\n  getRouteInfo(route, pathname, query, as, resolvedAs, routeProps) {\n    var _this3 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var existingRouteInfo, cachedRouteInfo, routeInfo, Component, __N_SSG, __N_SSP, _require, isValidElementType, dataHref, props;\n\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            existingRouteInfo = _this3.components[route];\n\n            if (!(routeProps.shallow && existingRouteInfo && _this3.route === route)) {\n              _context3.next = 4;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", existingRouteInfo);\n\n          case 4:\n            cachedRouteInfo = existingRouteInfo && 'initial' in existingRouteInfo ? undefined : existingRouteInfo;\n\n            if (!cachedRouteInfo) {\n              _context3.next = 9;\n              break;\n            }\n\n            _context3.t0 = cachedRouteInfo;\n            _context3.next = 12;\n            break;\n\n          case 9:\n            _context3.next = 11;\n            return _this3.fetchComponent(route).then(res => ({\n              Component: res.page,\n              styleSheets: res.styleSheets,\n              __N_SSG: res.mod.__N_SSG,\n              __N_SSP: res.mod.__N_SSP\n            }));\n\n          case 11:\n            _context3.t0 = _context3.sent;\n\n          case 12:\n            routeInfo = _context3.t0;\n            Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP;\n\n            if (!false) {\n              _context3.next = 18;\n              break;\n            }\n\n            _require = require('react-is'), isValidElementType = _require.isValidElementType;\n\n            if (isValidElementType(Component)) {\n              _context3.next = 18;\n              break;\n            }\n\n            throw new Error(\"The default export is not a React Component in page: \\\"\".concat(pathname, \"\\\"\"));\n\n          case 18:\n            if (__N_SSG || __N_SSP) {\n              dataHref = _this3.pageLoader.getDataHref((0, _utils.formatWithValidation)({\n                pathname,\n                query\n              }), resolvedAs, __N_SSG, _this3.locale);\n            }\n\n            _context3.next = 21;\n            return _this3._getData(() => __N_SSG ? _this3._getStaticData(dataHref) : __N_SSP ? _this3._getServerData(dataHref) : _this3.getInitialProps(Component, // we provide AppTree later so this needs to be `any`\n            {\n              pathname,\n              query,\n              asPath: as\n            }));\n\n          case 21:\n            props = _context3.sent;\n            routeInfo.props = props;\n            _this3.components[route] = routeInfo;\n            return _context3.abrupt(\"return\", routeInfo);\n\n          case 27:\n            _context3.prev = 27;\n            _context3.t1 = _context3[\"catch\"](0);\n            return _context3.abrupt(\"return\", _this3.handleRouteInfoError(_context3.t1, pathname, query, as, routeProps));\n\n          case 30:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3, null, [[0, 27]]);\n    }))();\n  }\n\n  set(route, pathname, query, as, data, resetScroll) {\n    this.isFallback = false;\n    this.route = route;\n    this.pathname = pathname;\n    this.query = query;\n    this.asPath = as;\n    return this.notify(data, resetScroll);\n  }\n  /**\n  * Callback to execute before replacing router state\n  * @param cb callback to be executed\n  */\n\n\n  beforePopState(cb) {\n    this._bps = cb;\n  }\n\n  onlyAHashChange(as) {\n    if (!this.asPath) return false;\n\n    const _this$asPath$split = this.asPath.split('#'),\n          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),\n          oldUrlNoHash = _this$asPath$split2[0],\n          oldHash = _this$asPath$split2[1];\n\n    const _as$split = as.split('#'),\n          _as$split2 = _slicedToArray(_as$split, 2),\n          newUrlNoHash = _as$split2[0],\n          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same\n\n\n    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n      return true;\n    } // If the urls are change, there's more than a hash change\n\n\n    if (oldUrlNoHash !== newUrlNoHash) {\n      return false;\n    } // If the hash has changed, then it's a hash only change.\n    // This check is necessary to handle both the enter and\n    // leave hash === '' cases. The identity case falls through\n    // and is treated as a next reload.\n\n\n    return oldHash !== newHash;\n  }\n\n  scrollToHash(as) {\n    const _as$split3 = as.split('#'),\n          _as$split4 = _slicedToArray(_as$split3, 2),\n          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value\n\n\n    if (hash === '') {\n      window.scrollTo(0, 0);\n      return;\n    } // First we check if the element by id is found\n\n\n    const idEl = document.getElementById(hash);\n\n    if (idEl) {\n      idEl.scrollIntoView();\n      return;\n    } // If there's no element with the id, we check the `name` property\n    // To mirror browsers\n\n\n    const nameEl = document.getElementsByName(hash)[0];\n\n    if (nameEl) {\n      nameEl.scrollIntoView();\n    }\n  }\n\n  urlIsNew(asPath) {\n    return this.asPath !== asPath;\n  }\n\n  _resolveHref(parsedHref, pages, applyBasePath = true) {\n    const pathname = parsedHref.pathname;\n    const cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(applyBasePath ? delBasePath(pathname) : pathname));\n\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n      return parsedHref;\n    } // handle resolving href for dynamic routes\n\n\n    if (!pages.includes(cleanPathname)) {\n      // eslint-disable-next-line array-callback-return\n      pages.some(page => {\n        if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {\n          parsedHref.pathname = applyBasePath ? addBasePath(page) : page;\n          return true;\n        }\n      });\n    }\n\n    parsedHref.pathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)(parsedHref.pathname);\n    return parsedHref;\n  }\n  /**\n  * Prefetch page code, you may wait for the data during page rendering.\n  * This feature only works in production!\n  * @param url the href of prefetched page\n  * @param asPath the as path of the prefetched page\n  */\n\n\n  prefetch(url, asPath = url, options = {}) {\n    var _this4 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      var parsed, _parsed2, pathname, parsedAs, localePathResult, pages, route;\n\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);\n            _parsed2 = parsed, pathname = _parsed2.pathname;\n\n            if (process.env.__NEXT_I18N_SUPPORT) {\n              if (options.locale === false) {\n                pathname = (0, _normalizeLocalePath.normalizeLocalePath)(pathname, _this4.locales).pathname;\n                parsed.pathname = pathname;\n                url = (0, _utils.formatWithValidation)(parsed);\n                parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(asPath);\n                localePathResult = (0, _normalizeLocalePath.normalizeLocalePath)(parsedAs.pathname, _this4.locales);\n                parsedAs.pathname = localePathResult.pathname;\n                options.locale = localePathResult.detectedLocale || _this4.defaultLocale;\n                asPath = (0, _utils.formatWithValidation)(parsedAs);\n              }\n            }\n\n            _context4.next = 5;\n            return _this4.pageLoader.getPageList();\n\n          case 5:\n            pages = _context4.sent;\n            parsed = _this4._resolveHref(parsed, pages, false);\n\n            if (parsed.pathname !== pathname) {\n              pathname = parsed.pathname;\n              url = (0, _utils.formatWithValidation)(parsed);\n            } // Prefetch is not supported in development mode because it would trigger on-demand-entries\n\n\n            if (!false) {\n              _context4.next = 10;\n              break;\n            }\n\n            return _context4.abrupt(\"return\");\n\n          case 10:\n            route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);\n            _context4.next = 13;\n            return Promise.all([_this4.pageLoader._isSsg(url).then(isSsg => {\n              return isSsg ? _this4._getStaticData(_this4.pageLoader.getDataHref(url, asPath, true, typeof options.locale !== 'undefined' ? options.locale : _this4.locale)) : false;\n            }), _this4.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);\n\n          case 13:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }))();\n  }\n\n  fetchComponent(route) {\n    var _this5 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n      var cancelled, cancel, componentResult, error;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            cancelled = false;\n\n            cancel = _this5.clc = () => {\n              cancelled = true;\n            };\n\n            _context5.next = 4;\n            return _this5.pageLoader.loadPage(route);\n\n          case 4:\n            componentResult = _context5.sent;\n\n            if (!cancelled) {\n              _context5.next = 9;\n              break;\n            }\n\n            error = new Error(\"Abort fetching component for route: \\\"\".concat(route, \"\\\"\"));\n            error.cancelled = true;\n            throw error;\n\n          case 9:\n            if (cancel === _this5.clc) {\n              _this5.clc = null;\n            }\n\n            return _context5.abrupt(\"return\", componentResult);\n\n          case 11:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }))();\n  }\n\n  _getData(fn) {\n    let cancelled = false;\n\n    const cancel = () => {\n      cancelled = true;\n    };\n\n    this.clc = cancel;\n    return fn().then(data => {\n      if (cancel === this.clc) {\n        this.clc = null;\n      }\n\n      if (cancelled) {\n        const err = new Error('Loading initial props cancelled');\n        err.cancelled = true;\n        throw err;\n      }\n\n      return data;\n    });\n  }\n\n  _getStaticData(dataHref) {\n    const _URL = new URL(dataHref, window.location.href),\n          cacheKey = _URL.href;\n\n    if (true && this.sdc[cacheKey]) {\n      return Promise.resolve(this.sdc[cacheKey]);\n    }\n\n    return fetchNextData(dataHref, this.isSsr).then(data => {\n      this.sdc[cacheKey] = data;\n      return data;\n    });\n  }\n\n  _getServerData(dataHref) {\n    return fetchNextData(dataHref, this.isSsr);\n  }\n\n  getInitialProps(Component, ctx) {\n    const App = this.components['/_app'].Component;\n\n    const AppTree = this._wrapApp(App);\n\n    ctx.AppTree = AppTree;\n    return (0, _utils.loadGetInitialProps)(App, {\n      AppTree,\n      Component,\n      router: this,\n      ctx\n    });\n  }\n\n  abortComponentLoad(as, routeProps) {\n    if (this.clc) {\n      Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);\n      this.clc();\n      this.clc = null;\n    }\n  }\n\n  notify(data, resetScroll) {\n    return this.sub(data, this.components['/_app'].Component, resetScroll);\n  }\n\n}\n\nexports.default = Router;\nRouter.events = (0, _mitt.default)();","map":null,"metadata":{},"sourceType":"script"}